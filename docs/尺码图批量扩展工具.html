<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>尺码图批量扩展工具 (高清版)</title>
    <style>
        /* --- 基本页面样式 (无变化) --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 970px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        h1, h2 {
            color: #333;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-top: 0;
        }

        /* --- 上传区域样式 (无变化) --- */
        .upload-section {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .main-upload-area {
            grid-column: 1 / -1;
        }

        .side-upload-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .upload-box {
            border: 2px dashed #ccc;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            background-color: #fafafa;
        }

        .upload-box label {
            font-weight: bold;
            display: block;
            margin-bottom: 10px;
            color: #555;
        }

        input[type="file"] {
            width: 100%;
        }
        
        #file-list-container {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            background: #f8f9fa;
        }
        
        #file-list li {
            background: #e9ecef;
            padding: 5px 8px;
            border-radius: 3px;
            margin-bottom: 5px;
            font-size: 14px;
            color: #495057;
        }

        /* --- 预览区域样式 (无变化) --- */
        /* CSS控制的是显示尺寸，保持不变，这样页面布局就不会乱 */
        #preview-canvas {
            width: 100%; 
            max-width: 970px; /* 仍然是970px，浏览器会自动缩放高清画布 */
            height: auto; 
            border: 1px solid #ccc;
            margin: 20px auto;
            display: block; 
        }
        
        /* --- 操作按钮和状态 (无变化) --- */
        #batch-status {
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            color: #007bff;
            height: 20px;
        }

        .action-button {
            display: block;
            width: 100%;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #28a745;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        .action-button:disabled {
            background-color: #9E9E9E;
            cursor: not-allowed;
        }

        .action-button:not(:disabled):hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>尺码图批量扩展工具 (高清版)</h1>
        
        <div class="upload-section">
            <div class="upload-box main-upload-area">
                <label for="main-image-upload">1. 批量上传主尺码图 (可一次选择多张)</label>
                <input type="file" id="main-image-upload" accept="image/*" multiple>
                <div id="file-list-container" style="display: none;">
                    <strong>待处理文件列表:</strong>
                    <ul id="file-list"></ul>
                </div>
            </div>
            <div class="side-upload-area">
                <div class="upload-box">
                    <label for="incorrect-image-upload">2. 上传“错误”示意图</label>
                    <input type="file" id="incorrect-image-upload" accept="image/*">
                </div>
                <div class="upload-box">
                    <label for="correct-image-upload">3. 上传“正确”示意图</label>
                    <input type="file" id="correct-image-upload" accept="image/*">
                </div>
            </div>
        </div>

        <h2>效果预览 (所见即所得)</h2>
        <!-- 变化1: 修改Canvas的width和height属性，以提高绘图分辨率 -->
        <canvas id="preview-canvas" width="1940" height="1200"></canvas>
        
        <div id="batch-status"></div>
        <button id="generate-btn" class="action-button" disabled>批量生成并下载 (ZIP)</button>
    </div>

    <a id="download-link" style="display: none;"></a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // --- DOM元素获取 (无变化) ---
        const mainImageUpload = document.getElementById('main-image-upload');
        const incorrectImageUpload = document.getElementById('incorrect-image-upload');
        const correctImageUpload = document.getElementById('correct-image-upload');
        const fileListContainer = document.getElementById('file-list-container');
        const fileList = document.getElementById('file-list');
        const batchStatus = document.getElementById('batch-status');
        const generateBtn = document.getElementById('generate-btn');
        const downloadLink = document.getElementById('download-link');
        
        const canvas = document.getElementById('preview-canvas');
        const ctx = canvas.getContext('2d');

        // --- 状态变量 (无变化) ---
        let mainImagesQueue = [];
        let mainPreviewImage = null;
        const sideImages = { incorrect: null, correct: null };

        // 变化2: 新增一个比例因子
        const scaleFactor = 2;

        // --- 初始化 ---
        window.onload = () => {
            drawOnCanvas();
        };

        // --- 事件监听 (无变化) ---
        mainImageUpload.addEventListener('change', handleMainImageUpload);
        incorrectImageUpload.addEventListener('change', (e) => handleSideImageUpload(e, 'incorrect'));
        correctImageUpload.addEventListener('change', (e) => handleSideImageUpload(e, 'correct'));
        generateBtn.addEventListener('click', handleGeneration);

        // --- 函数定义 ---
        
        // (handleMainImageUpload, handleSideImageUpload, checkAllImagesUploaded, loadImage 无变化)
        function checkAllImagesUploaded() {
            generateBtn.disabled = !(mainImagesQueue.length > 0 && sideImages.incorrect && sideImages.correct);
        }

        async function handleMainImageUpload(e) {
            mainImagesQueue = Array.from(e.target.files);
            fileList.innerHTML = '';
            
            if (mainImagesQueue.length > 0) {
                mainImagesQueue.forEach(file => {
                    const li = document.createElement('li');
                    li.textContent = file.name;
                    fileList.appendChild(li);
                });
                fileListContainer.style.display = 'block';

                try {
                    mainPreviewImage = await loadImage(mainImagesQueue[0]);
                    drawOnCanvas();
                } catch (error) {
                    console.error("加载主预览图失败:", error);
                    mainPreviewImage = null;
                }
            } else {
                fileListContainer.style.display = 'none';
                mainPreviewImage = null;
                drawOnCanvas();
            }
            checkAllImagesUploaded();
        }

        async function handleSideImageUpload(event, imageKey) {
            const file = event.target.files[0];
            if (file) {
                try {
                    sideImages[imageKey] = await loadImage(file);
                    drawOnCanvas();
                } catch (error) {
                    console.error(`加载示意图 ${imageKey} 失败:`, error);
                    sideImages[imageKey] = null;
                }
            }
            checkAllImagesUploaded();
        }

        // 变化3: 修改绘图辅助函数，使其接受比例化的字体大小
        function wrapAndDrawStyledText(context, text, x, y, maxWidth, lineHeight, boldWords, defaultFontSize, boldFontSize) {
            const words = text.split(' ');
            let currentX = x;
            let currentY = y;
            
            const defaultFont = `bold ${defaultFontSize}px Arial`;
            const boldFont = `bold ${boldFontSize}px Arial`;
            const defaultColor = '#333';
            const boldColor = '#e74c3c';

            context.font = defaultFont; // 先设置一个，用于计算空格宽度
            const spaceWidth = context.measureText(' ').width;

            for (let n = 0; n < words.length; n++) {
                const word = words[n];
                const isBold = boldWords.includes(word.replace(/[.,;]/g, ''));
                
                context.font = isBold ? boldFont : defaultFont;
                const wordWidth = context.measureText(word).width;

                if (currentX !== x && (currentX + wordWidth > x + maxWidth)) {
                    currentY += lineHeight;
                    currentX = x;
                }
                
                context.fillStyle = isBold ? boldColor : defaultColor;
                context.fillText(word, currentX, currentY);
                
                currentX += wordWidth + spaceWidth;
            }
            return currentY + lineHeight;
        }

        function drawContainedImage(ctx, img, x, y, boxWidth, boxHeight) {
            const imgAspectRatio = img.width / img.height;
            const boxAspectRatio = boxWidth / boxHeight;

            let finalWidth, finalHeight;

            if (imgAspectRatio > boxAspectRatio) {
                finalWidth = boxWidth;
                finalHeight = finalWidth / imgAspectRatio;
            } else {
                finalHeight = boxHeight;
                finalWidth = finalHeight * imgAspectRatio;
            }

            const offsetX = x + (boxWidth - finalWidth) / 2;
            const offsetY = y + (boxHeight - finalHeight) / 2;

            ctx.drawImage(img, offsetX, offsetY, finalWidth, finalHeight);
        }

        // 变化4: 核心绘图函数，所有硬编码的数值都乘以 scaleFactor
        function drawOnCanvas() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 主图区域
            const mainBoxSize = 600 * scaleFactor;
            ctx.fillStyle = '#e9ecef';
            ctx.fillRect(0, 0, mainBoxSize, mainBoxSize);
            if (mainPreviewImage) {
                drawContainedImage(ctx, mainPreviewImage, 0, 0, mainBoxSize, mainBoxSize);
            } else {
                ctx.fillStyle = '#6c757d';
                ctx.font = `${20 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`主尺码图区域 (${mainBoxSize}x${mainBoxSize})`, mainBoxSize / 2, mainBoxSize / 2);
            }
            
            // 右侧内容
            const padding = 25 * scaleFactor;
            const rightX = mainBoxSize + padding;
            const rightPanelWidth = 370 * scaleFactor;
            const contentWidth = rightPanelWidth - (padding * 2);
            let currentY = padding;

            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.font = `bold ${22 * scaleFactor}px Arial`;
            ctx.fillStyle = '#000000';
            ctx.fillText('Important Measurement Tips', rightX, currentY);
            currentY += (22 + 15) * scaleFactor;

            const listItems = [
                { text: "To ensure the best fit, please measure your dog's size and compare it with the size chart on the left.", bold: [] },
                { text: "When measuring, the tape should be snug but not too tight. You should be able to fit one or two fingers underneath.", bold: [] },
                { text: "For most apparel, the Chest Girth is the key measurement. Please prioritize it.", bold: ["Chest", "Girth"] },
                { text: "If your dog's measurements fall between two sizes, we recommend choosing the larger size for comfort.", bold: ["larger", "size"] }
            ];
            const listItemMarginBottom = 35 * scaleFactor;
            const listLineHeight = 28 * scaleFactor;
            const listFontSize = 15 * scaleFactor;

            listItems.forEach(item => {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(rightX, currentY + (8 * scaleFactor), 3 * scaleFactor, 0, 2 * Math.PI);
                ctx.fill();
                const textEndY = wrapAndDrawStyledText(ctx, item.text, rightX + (15 * scaleFactor), currentY, contentWidth - (15 * scaleFactor), listLineHeight, item.bold, listFontSize, listFontSize);
                currentY = textEndY - listLineHeight + listItemMarginBottom; 
            });
            
            // 底部示意图
            const smallImgBoxWidth = (contentWidth / 2) * 0.96;
            const smallImgBoxHeight = 120 * scaleFactor;
            const smallImgCaptionGap = 5 * scaleFactor;
            const smallImgTextHeight = 20 * scaleFactor;
            const smallImgTotalHeight = smallImgBoxHeight + smallImgCaptionGap + smallImgTextHeight;
            const remainingHeight = canvas.height - (currentY - listItemMarginBottom);
            const imgY = (currentY - listItemMarginBottom) + (remainingHeight - smallImgTotalHeight) / 2;
            const textY = imgY + smallImgBoxHeight + smallImgCaptionGap;
            const incorrectImgBoxX = rightX;
            const correctImgBoxX = rightX + contentWidth - smallImgBoxWidth;
            
            // 绘制错误示意图
            if (sideImages.incorrect) {
                drawContainedImage(ctx, sideImages.incorrect, incorrectImgBoxX, imgY, smallImgBoxWidth, smallImgBoxHeight);
            } else {
                ctx.strokeRect(incorrectImgBoxX, imgY, smallImgBoxWidth, smallImgBoxHeight);
                ctx.fillStyle = '#6c757d'; ctx.font = `${14 * scaleFactor}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('错误示意图', incorrectImgBoxX + smallImgBoxWidth / 2, imgY + smallImgBoxHeight / 2);
            }
            
            // 绘制正确示意图
            if (sideImages.correct) {
                drawContainedImage(ctx, sideImages.correct, correctImgBoxX, imgY, smallImgBoxWidth, smallImgBoxHeight);
            } else {
                ctx.strokeRect(correctImgBoxX, imgY, smallImgBoxWidth, smallImgBoxHeight);
                ctx.fillStyle = '#6c757d'; ctx.font = `${14 * scaleFactor}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('正确示意图', correctImgBoxX + smallImgBoxWidth / 2, imgY + smallImgBoxHeight / 2);
            }
            
            ctx.font = `bold ${14 * scaleFactor}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top'; // 使用top对齐，y坐标更精确
            ctx.fillStyle = '#c0392b';
            ctx.fillText('Incorrect: Too Tight', incorrectImgBoxX + smallImgBoxWidth / 2, textY, smallImgBoxWidth);
            ctx.fillStyle = '#27ae60';
            ctx.fillText('Correct: Snug Fit', correctImgBoxX + smallImgBoxWidth / 2, textY, smallImgBoxWidth);
            
            // 重置对齐方式，避免影响其他绘图
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }
        
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // (handleGeneration 无变化)
        async function handleGeneration() {
            generateBtn.disabled = true;
            batchStatus.textContent = '正在初始化...';

            const zip = new JSZip();
            const totalFiles = mainImagesQueue.length;

            for (let i = 0; i < totalFiles; i++) {
                const file = mainImagesQueue[i];
                batchStatus.textContent = `正在处理: ${i + 1} / ${totalFiles} (${file.name})`;

                try {
                    mainPreviewImage = await loadImage(file);
                    drawOnCanvas(); 
                    
                    const imageDataUrl = canvas.toDataURL('image/png');
                    const base64Data = imageDataUrl.split(',')[1];
                    zip.file(file.name.replace(/\.[^/.]+$/, "") + ".png", base64Data, { base64: true });

                } catch (error) {
                    console.error(`处理文件 ${file.name} 时出错:`, error);
                    batchStatus.textContent = `处理 ${file.name} 失败，已跳过。`;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            batchStatus.textContent = '正在生成ZIP文件...';
            zip.generateAsync({ type: "blob" })
                .then((content) => {
                    const url = URL.createObjectURL(content);
                    downloadLink.href = url;
                    downloadLink.download = 'generated-charts-HD.zip';
                    downloadLink.click();
                    URL.revokeObjectURL(url);

                    batchStatus.textContent = '批量处理完成！';
                    generateBtn.disabled = false;
                });
        }
    </script>
</body>
</html>